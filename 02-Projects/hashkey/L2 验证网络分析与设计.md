---
status: "进行中"
progress: "80%"
---

# L2 验证网络分析与设计

## 需求

1. 尽量不修改 Optimism 源码，或仅做少量兼容性改动。  
2. 保持架构去中心化，不引入中心化设计。

---

## 架构设计

![架构图](https://raw.githubusercontent.com/dreamer-zq/PicGo/main/img/image-20250109092937002.png)

### **Optimism**

对现有架构进行兼容性改动，将 **op-batcher** 和 **op-proposer** 配置中指向的 L1 网络替换为指向 **Validation Network (VN)** 网络。

### **Validation Network**

**Validation Network (VN)** 是一个分布式网络，由多个验证节点组成。验证人管理合约部署在 L1（Ethereum）上，负责验证人的注册、退出以及奖励等功能。  

#### **验证节点工作流程**

1. **注册与启动**：
   - 在成为验证节点前，需通过 VN 提供的命令完成验证人注册。
   - 注册完成后，验证人需在规定时间内启动验证节点。

2. **验证节点职责**：
   - 每个验证节点运行一个经过改造的执行层程序（基于 op-geth），保持与 L2 的状态一致。
   - 当验证节点收到 **op-batcher** 或 **op-proposer** 提交的数据后，会向整个验证网络广播消息。

3. **一致性投票**：
   - 验证节点对收到的数据进行验证，包括区块数据、交易及状态等。
   - 对验证通过的数据进行签名投票。
   - 若投票结果通过，验证网络通过一致性算法选出一个 proposer，由其负责将原始数据转发到 L1（Ethereum）。

#### **执行层的改造**

- **op-geth 的功能调整**：
  - 修改 API，使其仅具备接收数据的能力，不直接向验证网络执行任何交易。
  - 查询类 API 转发来自 L2 的请求至 L1（Ethereum）。

---

## 风险分析

1. **执行层的能力与改造复杂性**：  
   - 为全面验证提交数据的合法性（包括区块、交易、状态等），验证节点需要具备完整的执行层能力，同时避免产生新区块。  
   - 这可能需要对 op-geth 进行较大改动，需进一步调研实现的可行性。

2. **激励机制设计**：  
   - 验证节点的激励机制直接影响验证人合约的设计。
   - 为确保合约安全性和灵活性，可能需要设计可升级的合约，但这可能引入中心化风险。

3. **数据验证的完整性**：  
   - 需要确保 **op-batcher** 和 **op-proposer** 提交的数据能够满足验证所需的所有条件（如完整的区块、交易与状态信息）。

---

## 建议

### **op-batcher 上传数据格式**

```go
type BatchV1 struct {
	ParentHash common.Hash  // parent L2 block hash
	EpochNum   rollup.Epoch // aka l1 num
	EpochHash  common.Hash  // block hash
	Timestamp  uint64
	// no feeRecipient address input, all fees go to a L2 contract
	Transactions []hexutil.Bytes
}

type BatchData struct {
	BatchV1
	// batches may contain additional data with new upgrades
}
```
由于交易列表中剔除了 `DepositTxType` 类型的交易，仅依靠 `op-batcher `上传的数据无法重建完整 L2 区块信息。因此，无法让验证网络的节点与 L2 的节点保持相同的状态。~~建议仅验证交易的合法性（如交易签名）。~~

### **op-proposer 上传数据定义**

```solidity
/// @notice Accepts an outputRoot and the timestamp of the corresponding L2 block.
///         The timestamp must be equal to the current value returned by `nextTimestamp()` in
///         order to be accepted. This function may only be called by the Proposer.
/// @param _outputRoot    The L2 output of the checkpoint block.
/// @param _l2BlockNumber The L2 block number that resulted in _outputRoot.
/// @param _l1BlockHash   A block hash which must be included in the current chain.
/// @param _l1BlockNumber The block number with the specified block hash.
function proposeL2Output(
    bytes32 _outputRoot,
    uint256 _l2BlockNumber,
    bytes32 _l1BlockHash,
    uint256 _l1BlockNumber
) external payable 
```
_outputRoot 的计算逻辑如下：
```go
func ComputeL2OutputRoot(proofElements *bindings.TypesOutputRootProof) (eth.Bytes32, error) {
	if proofElements == nil {
		return eth.Bytes32{}, NilProof
	}

	digest := crypto.Keccak256Hash(
		proofElements.Version[:],
		proofElements.StateRoot[:],
		proofElements.MessagePasserStorageRoot[:],
		proofElements.LatestBlockhash[:],
	)
	return eth.Bytes32(digest), nil
}

func ComputeL2OutputRootV0(block eth.BlockInfo, storageRoot [32]byte) (eth.Bytes32, error) {
	var l2OutputRootVersion eth.Bytes32 // it's zero for now
	return ComputeL2OutputRoot(&bindings.TypesOutputRootProof{
		Version:                  l2OutputRootVersion,
		StateRoot:                block.Root(),
		MessagePasserStorageRoot: storageRoot,
		LatestBlockhash:          block.Hash(),
	})
}
```
_outputRoot 是多种数据的哈希值。如果要验证其有效性，只能通过重建数据后进行比对（这同样需要与 L2 保持相同的状态）。~~因此，不建议完全验证其有效性。~~

---

## 总结

此架构在保持去中心化的同时增强了数据验证的可靠性，但实际实施可能面临技术和设计上的挑战。建议在设计中综合考虑实现成本与网络安全性。